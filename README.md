# hash-storage

## Description

Hash Storage is a web service that provides an opportunity to upload and modify data keeping its ownership (using signatures according to [ECDSA](https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm)). Briefly, everybody who has a private key can put data into a Hash Storage instance but nobody can modify the data silently, even the owner of the instance. Also everybody can read the data (if it is not encrypted). Particularly, it is allowed to encrypt the put data (with, for example, [AES-256](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard) algorithm) before saving, so everybody can read this record in the Hash Storage instance, but nobody can read and modify the original phrase. Thus Hash Storage can be a fully secure cloud service. It is a perfect solution if the clients are supposed not to trust the server side.

Hash Storage uses 256-bit ECDSA over [Secp256k1](https://en.bitcoin.it/wiki/Secp256k1) (Bitcoin curve).

Hash Storage is written in Rocket (Rust). It includes [bigi-ecc](https://github.com/fomalhaut88/bigi-ecc) as the library to work with the cryptography issues inside. As the database MySQL is used.


## How it works

In Hash Storage, data are stored as key-value records (fields **data_key** and **data_block**), that have their owners (field **public_key**), signatures (field **signature**) and secrets (field **secret**, it is needed to allow clients to modify of to delete the record). Data records can be grouped and each one may have its own version. Group and version can be empty.

Fields of a record:

* public_key - the owner of the record, 256-bit public key as a point on Secp256k1.
* data_group - the group (it can be empty).
* data_key - key of the data, any string (the length is up to 64 characters).
* data_block - value of the data, any string up to 16 MB.
* data_version - the version of the data (it can be empty).
* signature - ECDSA signature built from concatenated data_group, data_key, data_block and data_version hashed with [SHA-256](https://en.wikipedia.org/wiki/SHA-2) algorithm.
* secret - secret string, a random string with 32 characters (256 bits) generated by Hash Storage on data insert.

The database has a unique key: (public_key, data_group, data_key).

### Generating keys

On the client side, before working with records, it is necessary to generate a key-pair on Secp256k1. Private key should be stored reliably somewhere, public key will be used in data records. Hash Storage will check the ownership with the help of the public key. Private key is needed to generate signatures.

### Creating a signature

First, it is necessary to concatenate **data_group**, **data_key**, **data_block** and **data_version** into a single byte sequence. After that, SHA-256 algorithm must be applied to it, so there will be a 256-bit hash as the result. In the end, a signature can be created from this hash using ECDSA algorithm. Hash Storage checks the signature on save.

### Secret field

The field **secret** is added to protect the existing data record from undesired modifications. Secret is generated by the service automatically when a new data record is inserted. To update or delete a record it is not enough to create its signature. Otherwise an intruder potentially could repeat some of your previous requests and roll the state of the record back. Thus, in Hash Storage, it is necessary to create a separate signature for the secret (it is called **secret_signature**), such that the service could check it and be aware that the author of changes does have the private key.

### Number format

All the numbers (private and public keys, signatures, secret, etc) must be in HEX format with upper case for the letters and without leading 0x. Here is an example of a valid private key:

    12BEC995D37D5267AD734B5B63FFFF048A511F71CD086D3E212FF13C9A037FD1


## Advantages and disadvantages of Hash Storage comparing to ordinary cloud services

Advantages:
- each record has a proof of client ownership,
- the owner of a Hash Storage instance is unable to modify the data,
- the owner of a Hash Storage instance is unable to read, analyze and share with 3rd parties the records if they are encrypted,
- same Hash Storage instance can be easily and naturally used for multiple projects,
- no need to use SSL usually (HTTPS is acceptable, but usually it is not necessary, because everything is already encrypted well enough; although everything depends on the sort of the data in the project).

Disadvantages:
- relatively complicated way to manage the data.


## Areas to use

- Storing private data of the clients (passwords, private notes, location, financial details, etc),
- Publishing open information with its ownership.


## Recommendations to use

### Generating a key-pair by username and password within a custom application

As far as a private key is a 256-bit number, it can be some hash of username, password, project ID or any other data that can identify the client in a custom application. Simply it is possible to use SHA-256 hash for it. The public key can be generated according to ECC on Secp256k1 as a multiplication on the generator. For Frontend Development, there is a library [hash-storage-wasm](https://github.com/fomalhaut88/hash-storage-wasm) written in Rust, specially for Hash Storage, that has all the necessary functions to manage the keys: **get_private_key**, **get_public_key**, **check_keys**. One of the recommended ways to hash the data is following:

    SHA256({APP_UUID}:{USERNAME}:{PASSWORD})

Where **APP_UUID** is a unique identifier of the application (it can be [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier), for example), you should use it if you have multiple applications that work with the same Hash Storage instance. The password should contain as least 12 symbols with upper and lower cases and digits.

### Data encryption

To encrypt data before sending to Hash Storage, it is a good idea to encrypt it with AES-256 using the private key as a password. It is enough because nobody except for the client knows the private key, so nobody can decrypt the data (unless AES-256 algorithm is broken, of course). The other way is to use [ElGamal encryption](https://en.wikipedia.org/wiki/ElGamal_encryption) that included to [hash-storage-wasm](https://github.com/fomalhaut88/hash-storage-wasm) in the functions **encrypt**, **decrypt**.

### Signatures

The signatures must be generated according to ECDSA, keeping the number format described above. It is possible to do it with any software. For the Frontend Development there are special functions called **build_signature**, **check_signature**, **build_secret_signature**, **check_secret_signature** in [hash-storage-wasm](https://github.com/fomalhaut88/hash-storage-wasm).

### Version of the last uploaded record

To prevent any possibility of rolling back the data on the server side stealthily by the owner of the Hash Storage instance, it is recommended to manage versions of the records. As far as the data records are and were signed by the signatures, it is impossible to put a completely new record with he correct signature. But it is still possible to repeat one of the previous requests to set a previous state of the record (with the right signature). Using incrementing versions on each save and storing the value of the last version on the client side, it is easy to detect if the remote version has been changed (decremented) by somebody.


## Methods

| URL | Method | Description | Request example | Response example |
|---|---|---|---|---|
| /version | GET | Version of the Hash Storage instance. | | ```{"version":"1.0.1"}``` |
| /check | POST | Check whether a record with the specified public key exists in the storage. | ```{"public_key":"ED93...66"}``` | ```{"exists":true}``` |
| /groups | POST | List of available groups. | ```{"public_key":"ED93...66"}``` | ```["My group 1", "Group 2"]``` |
| /keys | POST | Data keys of a group. | ```{"public_key":"ED93...66", "data_group":"Group 2"}``` | ```["Key 1", "1276357"]``` |
| /list | POST | List of records in the group. | ```{"public_key":"ED93...66", "data_group":"Group 2"}``` | ```[{"id":81, "public_key":"ED93...66", "data_group":"Group 2", "data_key": "Key 1", "data_block":"Shared info", "data_version":"5", "signature":"FCED...C8", "secret":"736C...B7"}, {"id":82, "public_key":"ED93...66", "data_group":"Group 2", "data_key": "1276357", "data_block":"2Pcn...PR", "data_version":"25", "signature":"B8B0...E7", "secret":"05E0...FA"}]``` |
| /get | POST | Get a record by its group and key. | ```{"public_key":"ED93...66", "data_group":"Group 2", "data_key": "Key 1"}``` | ```{"id":81, "public_key":"ED93...66", "data_group":"Group 2", "data_key": "Key 1", "data_block":"Shared info", "data_version":"5", "signature":"FCED...C8", "secret":"736C...B7"}``` |
| /save | POST | Save a record (secret_key must be empty if it is a new record). | ```{"public_key":"ED93...66", "data_group":"Group 2", "data_key": "Key 1", "data_block":"My shared info", "data_version":"6", "signature":"088A...48", "secret_signature":"17AD...02"}``` | ```{"id":81, "public_key":"ED93...66", "data_group":"Group 2", "data_key": "Key 1", "data_block":"My shared info", "data_version":"6", "signature":"088A...48", "secret":"DD03...98"}``` |
| /delete | POST | Delete a record by its group and key. | ```{"public_key":"ED93...66", "data_group":"Group 2", "data_key": "Key 1", "secret_signature":"17AD...02"}``` | ```{"success":true}```


## How to deploy Hash Storage

### 1. Install the dependencies

1. Install Docker.
2. Install Nginx.
3. Install MySQL server.

### 2. Cloning the repository

```
git clone https://github.com/fomalhaut88/hash-storage.git
cd hash-storage
```

### 3. Configure MySQL

1. Ensure the access to MySQL server from docker containers. Usually it is enough to comment the line `bind-address = 127.0.0.1` in `/etc/mysql/mysql.conf.d/mysqld.cnf`.
2. Create a database `hash_storage`.
3. Create a user `hash_storage` with a password. Grant all privileges to it on the database `hash_storage`.

### 4. Configure Nginx

1. Copy Nginx configuration to `sites-available`: ```cp nginx/hashstorage.conf /etc/nginx/sites-available/```
2. In the copied file `/etc/nginx/sites-available/hashstorage.conf` set the correct domain instead of `hash-storage.domain` and the correct port instead of `8000` to proxy.
3. Create SSL certificates and ensure the correct paths to them in the configuration.
4. Create a link in `sites-enabled`: ```ln -s /etc/nginx/sites-available/hashstorage.conf ../sites-enabled/hashstorage```
5. Restart the service: ```service nginx restart```

### 5. Configure Docker

1. Copy the restart script: ```cp restart-example.sh restart.sh```
2. Modify `restart.sh`: set the correct password for the created `hash_storage` user in MySQL.
3. Modify `restart.sh`: set the correct port (that specified in Nginx configuration in `proxy_pass`).
4. Make sure that the MySQL server has IP address 172.17.0.1 from the inside of the docker container (if it is not, it is necessary to set the right IP address in `restart.sh` for `DATABASE_URL`).

### 5. Configure Rocker

1. Copy Rocket configuration: ```cp Rocket-example.toml Rocket.toml```
2. Generate and save a new secret key in `Rocket.toml`.

### 6. Run Hash Storage instance

```
./restart.sh
```

### 7. Check

```
curl your.hashstorage.domain/api/v1/version
```

The version of the service must be shown.


## Projects that use Hash Storage

Qnote - cloud based browser application to make notes: https://github.com/fomalhaut88/qnote

Domestic - an application to manage housework: https://github.com/fomalhaut88/domestic
